# Added on_error method

# simple calc parser

class Calcp

	prechigh
		nonassoc UMINUS
		left '^'
		left '*' '/'
		left '+' '-'
	preclow

rule

	target
		: exp
		| /* none */ { result = 0 }
		;

	num
		: NUMBER { result = result.to_i }
		| '_' { result = @last_value }
		;

	# note result = val[0] by default
	exp
		: exp '+' exp { result += val[2]; puts val.inspect, _values.inspect }
		| exp '-' exp { result -= val[2] }
		| exp '*' exp { result *= val[2] }
		| exp '/' exp { result /= val[2] }
		| exp '^' exp { result **= val[2] }
		| '(' exp ')' { result = val[1] }
		| '-' num = UMINUS { result = -val[1] }
		| num
		;

end


---- header ----

# calc.rb : generated by racc

require 'strscan'

---- inner ----
 
	def initialize
		@last_value = 0
	end
 
	def parse( str )
		tokens = []
		scanner = StringScanner.new(str)

		until scanner.empty?
			case
				when scanner.scan(/\s+/)
					# ignore space
				when m = scanner.scan(/\d+/)
					tokens.push [:NUMBER, m]
				when m = scanner.scan(/.|\n/)
					tokens.push [m, m]
			end
		end
		tokens.push [false, false]

		#@yydebug = true
		@last_value = yyparse(tokens, :each)
	end

	def on_error(error_token_id, error_value, value_stack)
		msg = "parse error "
		msg << "after #{value_stack.last} " if value_stack.length > 1
		#msg << "after #{value_stack.last} " unless value_stack.empty?
		msg << "on #{token_to_str(error_token_id)} #{error_value}"
		raise ParseError, msg
	end

---- footer ----

parser = Calcp.new
count = 0
scnt	= 0

puts
puts 'type "Q" to quit.'
puts

while true do
	puts
	print '? '
	str = gets.chop!
	break if /q/i === str

	begin
		val = parser.parse( str )
		print '= ', val, "\n"
	rescue ParseError
		puts $!
	end

end
